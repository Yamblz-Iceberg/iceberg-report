# Техническая защита

## О проекте

Яндекс.Айсберг – это сервис с подборками ссылок по различным темам, где можно удобно читать авторские подборки,а также составлять свои, делиться опытом с другими.

Нашей команде была поставлена задача разработать приложение со следующим функционалом:

- Лента созданных подборок, которая подстаивается под пользователя;
- Отображение детальной информации о созданной подборке и список ссылок в подборке;
- Поиск по подборкам;
- Возможность логиниться в приложении через соцсети;
- Возможность создавать собственные подборки и добавлять в них ссылки;
- Просмотр своего профиля с подробной информацией о добавленных подборках и ссылках, просмотр профилей других пользователей;

## Фронтенд

### Cordova

В качестве платформы для разработки мобильного приложения мы использовали **Cordova**. В первую очередь этот выбор обусловлен простотой разработки и большим количеством плагинов, предоставляющих нативный функционал. Вот несколько из них:

**cordova-plugin-safariviewcontroller**

Этот плагин позволяет просматривать веб-страницы внутри приложения. Он был выбран как альтернатива похожему по функционалу cordova-plugin-inappbrowser по ряду причин:

- Использует Safari Webview главного браузера системы на iOS, который быстрей чем UIWebView;
- Это рекомендумый Apple способ для таких ситуаций;
- Поддерживает Android OS.

**cordova-plugin-file**

Плагин отвечает за работу с файловой системой устройства. Мы столкнулись с проблемой отображения изображений при билде на телефоны, так как некорректно указывался путь до нужного локального файла. Использование этого плагина позволило решить эту задачу для обоих платформ.

### React

Основой фронтенд-стека был выбран **React**. Причин у этого выбора несколько:

- Компонентный подход данной библиотеки гибок и позволяет удобно и эффективно решать поставленную задачу.
- Большая часть команды была уже хотя бы частично знакома с React, что позволило не тратить время на выбор компромисса и изучение новой технологии.
- Комьюнити React огромно, а это значит, что на большинство вопросов, возникающих в процессе разработки, можно найти ответ в статьях, туторилах или на специальных ресурсах.

Для навигации между экранами и логики переключения мы использовали **React Router v4**.

### Redux

При выборе модели данных мы обратили внимание на **Redux**. Этот выбор объясняется желанием иметь централизованное хранилище, с помощью которого удобно отслеживать потоки данных в приложении, а также желанием упростить взаимодействие с сервером. В качестве middleware для Redux мы используем **Thunk**.

При разработке и отлаживании проекта очень помог **Redux Devtools**. С помощью этого инструмента мы быстро отлаживали и тестировали модель данных, искали баги.

### Линтеры

В работе над проектом мы использовали **ESLint** c пресетом от Airbnb. Часть правил конфигурации мы переписали в соответствии со своими предпочтениями.

Также в проекте использовался **Stylelint** с пресетом от HTML Academy.

### Сборка

Собирали проект с помощью **Webpack**. Конфиг писали сами, с нуля, учитывая особенности разработки гибридного приложения и предпочтения команды. Конфигурация разделена на два файла – production и development.

Для удобства и повышения скорости разработки в development режиме мы использовали **WebpackDevServer** и **HotModuleReplacementPlugin**. Сервер при старте билдит `index.html` (необходимо для того, чтобы Cordova собрала проект), а после следит за изменениями в папке `src` и в случае необходимости обновляет бандл `bundle.js`.

В loaders у нас находятся:

- `babel-loader` для транспиляции React и ES6+ синтаксиса;
- `style-loader`, `css-loader` и `sass-loader` для преобразования SASS в CSS и последующей сборки в `bundle.css`;
- `file-loader` для шрифтов, SVG-иконок и прочего;
- `eslint-loader` для линтинга.

Для удобства отладки в процессе разработки мы настроили **Source Map**.

### Тесты

В качестве инструмента для тестирования мы выбрали Jest. Из-за нехватки времени мы не смогли покрыть тестами весь код, а ограничились написанием тестов для редьюсеров.

### Тестирование на девайсах

В процессе разработки мы использовали эмуляторы устройств, а также тестировали приложение на различных реальных девайсах. Среди них были iPhone 5-7, устройства на Android с версиями 5-8.

### Разное

_(Может как-то переименовать этот раздел?)_

В архитектуре файловой системы проекта и в наименовании классов мы старались придерживаться методологии **БЭМ**.

_(Где-то нужно написать про CI)_

## Бэкенд

На бэкенде мы используем Node.JS, Express, MongoDB + множество разных библиотек, которые существенно ускоряют разработку.

### Node.JS + Express

Node.JS – отличный выбор в ситуации, когда нужно быстро написать бэкенд силами фронтэнд-разработчиков.

В качестве фреймворка был выбрал Express – минималистичный инструмент, с помощью которого можно легко создать как простой сервер, так и сложное API.

Код серверной части написан с ипользованием стандарта ES6. В процессе разработки использовлся линтер с конфигом от Airbnb.

Далее будут перечислены дополнительные модули/библиотеки, которые использовались в разработке:

- Защита:
  - Cors - по умолчанию *;
  - Helmet - заголовки для исключения базовых атак;
  - Express-rate-limit - ограничение количества запросов для одного IP.
- Обработка ошибок:
  - Morgan, winston - красивые логи в консоли;
  - API-errors - создание ошибок вида: статус, код ошибки, сообщение;
  - Своя обертка для классификации ошибок (добавление поля "тип ошибки").
- Расширение функционала Express:
  - Body parser - парсинг body запроса;
  - Compression - сжатие ответа сервера;
  - Static - размещение статических файлов;
- Аутентификация и регистрация:
  - Passport - используемые стратегии: Basic, Local, BearerStrategy, ClientPasswordStrategy, Yandex, VK, Facebook и Oauth2.
  - Oauth2orize - собственный сервер OAuth2, который прекрасно работает в связке с passport.
  - При первом заходе в приложение автоматически создаётся demo пользователь, у которого закрыты некоторые методы, например создание контента. После последующей авторизации через соцсети, вся информация накопленная за demo пользователем перейдет к полноценному авторизованному через соцсети пользователю, также доступны методы логаута со всех устройств.
- Статика:
  - Firebase Storage – модуль для хранения статики. Бесплатный тариф предоставляет 5GB места на диске + 1GB трафика в день, чего на нашем этапе вполне достаточно.
- Promise:
  - BlueBird – множество полезных надстроек над стандартными промисами (например, Promise.each).
- Управлениями процессами:
  - PM2 – красивые логи, статистика, кластеризация.
- Валидация:
  - Express-validator - удобные middleware для валидации запросов, избавляют от дополнительных проверок в самих роутах.
- База данных:
  - MongoDB - мы выбрали ее, так как она очень проста в изучении + для наших задач хорошо подходи документоориентированая СУБД. Для удобной работы с базой данных используется библиотека mongoose, модуль passport-local (удобное создание пользователей с шифрованием паролей), а также модуль findOrCreate. Связи между коллекциями устанавливаются по id mongo, а при выдаче результата используется aggregation pipeline с lookup.
- Фичи, выполняющиеся на сервере:
  - ColorThief - определение среднего цвета;
  - Jimp - изменение размера картинок;
  - Cheerio, Find Favicon, Image Resolver - парсинг страниц ссылок.

### Heroku

В качестве платформы для хостинга мы используем Heroku. Этот выбор обусловлен бесплатностью серсиса, простотой деплоя и интеграцией с GitHub (можно настроить автоматический деплой из ветки репозитория).

Однако, чем больше библиотек стал использовать проект, тем больше стало возникать технических трудностей. Некоторые из них:

- Трудности хранения файлов (файловая система на Heroku недоступна). Эта проблема была решена переносом статики на Firebase.
- Как следствие деплоя из открытого репозитория, необходимо было организовать хранение конфигов. Мы решили зашифровать конфиги с помощью cryptoJSON, а ключ передавать как переменную среды.

### Apiary и Dredd

Изначально для тестов планировалось использовать связку mocha + chai + chai-http, но потом выбор изменился в сторону Apiary (документация + тестирование с помощью dredd с небольшими hook'ами). Конечно, это не комплексное тестирование API, но при желании можно дописать необходимое в hook файлах с использованием того же chai. В итоге мы имеем базовое покрытие и хорошую документацию.

### Travis CI

После написания тестов мы настроили CI, используя веб-сервис Travis CI. Как и в случае с Heroku, пришлось немного помучаться с настройкой конфига для запуска билда.

## Коммуникация и командная работа

### Взаимодействие в команде

Первоначально оценив объем планируемой работы, мы распредились следующим образом: 4 человека на клиентскую часть и 1 на серверную. С развитием проекта эта расстановка работала успешно, задачи решались согласно планируемому графику.

Некоторые из нас до второго этапа мобилизации не имели практики командной работы над одним общим проектом. Мы стрались выслушивать друг друга и находить компромиссы в спорных мнениях. Не всегда это удавалось, но крупных конфликтов удалось избежать. Взаимное командное уважение осталось всегда на хорошем уровне.

Взаимодействие с менеджерской и дизайнерской стороной происходило без затруднений. Видение продукта и его формирование было единым - нам не ставили невыполнимых задач и всегда выслушивали мнение технической стороны.

Каждое утро менеджер проводил стендапы, на которых обсуждались выполненные задачи и ставились новые. Это помогало держать всю команду в курсе событий,выслушивать мнения каждого члена команды по важным вопросам.

Для онлайн коммуникации мы использовали Slack (важные сообщения, общение с кураторами, результаты стендапов) и Telegram (для более неформального общения внутри команды).

### Коммуникация в команде разработчиков

Мы создали на GitHub аккаунт организации, где объединили репозитории клиентской и серверной части. Это получилось весьма удобно - они всегда находились под общим наблюдением и при этом оставались полностью независимы, каждый со своей внутренней кухней.

Так как большую часть времени вся техническая команда работала оффлайн в одном помещении, мы решили не использовать сложные таск-менеджеры и в планировании задач ограничились GitHub Issues. Для удобства каждое issue помечалось тегом, который показывал категорию задачи (bug, refactoring, feature и т.д.).

В качестве модели разработки мы выбрали следующую схему:

- Ветка `master` защищена, при очередном релизе с ней сливается ветка `dev`;
- Ветка `dev` защищена, с ней сливаются рабочие ветки, для сливания необходим код ревью;
- Рабочие ветки называются в соответствии с номером issue, которое описывает изменения в этой ветки (новая фича, правка багов и пр.). Например, `issue-#100`.

При работе над клиентской частью мы практиковали **pull request code reviews**. Обязательные ревью перед слиянием ветки в `dev` улучшали качество кода, помогали находить «глупые» ошибки (опечатки) в реализации и повышали степень совместного владения кодом.

Из-за сильно ограниченных сроков мы решили не тратить время на написание подробной документации проекта. Стендапы и постоянное командное общение держали каждого разработчика в курсе происходящего.

Проектная коммуникация разработчиков с дизайнером строилась следующим образом: дизайнер отрисовывал макеты в **Sketch**, а после экспортировал их в **Zeplin**, в котором каждый разработчик мог удобно просматривать экраны и необходимые размеры, экспортировать графику и т.п.

## Чему научились

_(Рассказать, чему мы научились)_

## Планы на будущее

- Кеширование

_(Тут нужно рассказать о том, какие крутые штуки мы планируем сделать в будущем)_
