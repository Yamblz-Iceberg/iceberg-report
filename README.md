# Техническая защита

## О проекте

_(Описать о чем наш продукт, какая была постановка задачи)_

## Фронтенд

### Cordova

В качестве платформы для разработки мобильного приложения мы использовали **Cordova**. В первую очередь этот выбор обусловлен простотой разработки и большим количеством плагинов, предоставляющих нативный функционал.

_(Тут было бы круто написать про плагины)_

### React

Основой фронтенд-стека был выбран **React**. Причин у этого выбора несколько:

- Компонентный подход данной библиотеки гибок и позволяет удобно и эффективно решать поставленную задачу;
- Большая часть команды была уже хотя бы частично знакома с React, что позволило не тратить время на выбор компромисса и изучение новой технологии;
- Комьюнити React огромно, а это значит, что на большинство вопросов, возникающих в процессе разработки, можно найти ответ в статьях, туторилах или на специальных ресурсах.

Для навигации между экранами и логики переключения мы использовали **React Router v4**.

### Redux

При выборе модели данных мы обратили внимание на **Redux**. Этот выбор объясняется желанием иметь централизованное хранилище, с помощью которого удобно отслеживать потоки данных в приложении, а также желанием упростить взаимодействие с сервером. В качестве middleware для Redux мы используем **Thunk**.

При разработке и отлаживании проекта очень помог **Redux Devtools**. С помощью этого инструмента мы быстро отлаживали и тестировали модель данных, искали баги.

### Линтинг

В работе над проектом мы использовали **ESLint** c пресетом от Airbnb. Часть правил конфигурации мы переписали в соответствии со своими предпочтениями (можно привести пример исправлений).

### Сборка

Собирали проект с помощью **Webpack**. Конфиг писали сами, с нуля, учитывая особенности разработки гибридного приложения и предпочтения команды. Конфигурация разделена на два файла – production и development.

Для удобства и повышения скорости разработки в production режиме мы использовали **WebpackDevServer** и **HotModuleReplacementPlugin**. Сервер при старте билдит `index.html` (необходимо для того, чтобы Cordova собрала проект), а после следит за изменениями в папке `src` и в случае необходимости обновлял бандл `bundle.js`.

В loaders у нас находятся:

- `babel-loader` для транспиляции React и ES6+ синтаксиса;
- `style-loader`, `css-loader` и `sass-loader` для преобразования SASS в CSS и последующей сборки в `bundle.css`;
- `file-loader` для шрифтов, SVG-иконок и прочего;
- `eslint-loader` для линтинга.

Для удобства отладки в процессе разработки мы настроили **Source Map**.

### UNIT-тесты

_(Написать что-то невероятно крутое про наши тесты)_

### Тестирование на девайсах

В процессе разработки мы использовали эмуляторы, а также тестировали приложение на различных реальных девайсах. Среди них были iPhone 5-7, устройства на Android с версиями 5-8.

### Разное

_(Может как-то переименовать этот раздел?)_

В архитектуре файловой системы проекта и в наименовании классов мы старались придерживаться методологии **БЭМ**.

_(Написать про CI. Что мы не стали настраивать Continuous Integration, потому что на настройку и поддержку CI ушло бы много времени. Но CI – это круто!)_

## Бэкенд

_(Рассказать про сервер на NodeJS + Express, о всех крутых фишках, о статике на Firebase и пр. Структура дол)_

## Коммуникация и командная работа

Для онлайн коммуникации мы использовали Slack (важные сообщения, общение с кураторами, результаты стендапов и пр.) и Telegram (для более неформального общения).

Каждое утро менеджер проводил стендапы, на которых обсуждались выполненные задачи и ставились новые. Это помогало держать всю команду в курсе событий,выслушивать мнения каждого члена команды по важным вопросам.

Так как большую часть времени вся техническая команда работала оффлайн в одном помещении, мы решили не использовать сложные таск-менеджеры и в планировании задач ограничились GitHub Issues. Для удобства каждое issue помечалось тегом, который показывал категорию задачи (bug, refactoring, feature и т.д.).

В качестве модели разработки мы выбрали следующую схему:

- Ветка `master` защищена, при очередном релизе с ней сливается ветка `dev`;
- Ветка `dev` защищена, с ней сливаются рабочие ветки, для сливания необходим код ревью;
- Рабочие ветки называются в соответствии с номером issue, которое описывает изменения в этой ветки (новая фича, правка багов и пр.). Например, `issue-#100`.

При работе над клиентской частью мы практиковали **pull request code reviews**. Обязательные ревью перед слиянием ветки в `dev` улучшали качество кода, помогали находить «глупые» ошибки (опечатки) в реализации и повышали степень совместного владения кодом.

Проектная коммуникация разработчиков с дизайнером строилась следующим образом: дизайнер отрисовывал макеты в **Sketch**, а после экспортировал их в **Zeplin**, в котором каждый разработчик мог удобно просматривать экраны и необходимые размеры, экспортировать графику и т.п.

## Чему научились
